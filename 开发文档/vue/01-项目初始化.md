# 一、项目初始化

## （一）使用 Vue CLI 创建项目

> 注意：不要使用 Git Bash 执行项目创建操作，使用  cmd 或者 powershell 之类的工具。

> 如果你还没有安装 VueCLI，或者版本低于 4，请执行下面的命令安装或是升级：
>
> ```shell
> npm install --global @vue/cli
> ```

在命令行中输入以下命令创建 Vue 项目：
```shell
vue create material-vue
```

```shell
Vue CLI v4.5.11
? Please pick a preset: (Use arrow keys)
> Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
  Manually select features   
```
> default：默认勾选 babel、eslint，回车之后直接进入装包
>
> manually：自定义勾选特性配置，选择完毕之后，才会进入装包
>
> 选择第 2 种：手动选择特性，支持更多自定义选项


```shell
Vue CLI v4.5.11
? Please pick a preset: Manually select features
? Check the features needed for your project:
 (*) Choose Vue version
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
>(*) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing                                                                                                                           
```
分别选择：

> Choose Vue version：选择vue的版本
> Babel：es6 转 es5
> Router：路由
> Vuex:  实现多组件状态管理。多个组件之间需要数据共享时
> CSS Pre-processors：CSS 预处理器，后面会提示你选择 less、sass、stylus 等
> Linter / Formatter：代码格式校验，ESLint 代码格式校验

```
Vue CLI v4.5.11
? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, CSS Pre-processors, Linter
? Choose a version of Vue.js that you want to start the project with
  2.x
> 3.x (Preview)      
```

> 2.X： vue2.0以上版本  3.X：vue3.0以上版本，选择3.X


```shell
Vue CLI v4.5.11
? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, CSS Pre-processors, Linter
? Choose a version of Vue.js that you want to start the project with 3.x (Preview)
? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) n          
```
> 是否使用 history 路由模式，这里输入 `n` 不使用


```shell
Vue CLI v4.5.11
? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, CSS Pre-processors, Linter
? Choose a version of Vue.js that you want to start the project with 3.x (Preview)
? Use history mode for router? (Requires proper server setup for index fallback in production) No
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default):
  Sass/SCSS (with dart-sass)
  Sass/SCSS (with node-sass)
> Less
  Stylus 
```
> 选择 CSS 预处理器，这里选择我们熟悉的 Less


```shell
? Pick a linter / formatter config:
  ESLint with error prevention only
  ESLint + Airbnb config
> ESLint + Standard config
  ESLint + Prettier  
```
> 选择校验工具，这里选择 ESLint + [Standard config](https://standardjs.com/)


```shell
? Pick additional lint features:
 (*) Lint on save
>(*) Lint and fix on commit
```
> 选择在什么时机下触发代码格式校验：
> - Lint on save：每当保存文件的时候
> - Lint and fix on commit：每当执行 `git commit` 提交的时候
>
> 这里建议两个都选上，更严谨。


```shell
? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
> In dedicated config files
  In package.json
```
> Babel、ESLint 等工具会有一些额外的配置文件，这里的意思是问你将这些工具相关的配置文件写到哪里：
> - In dedicated config files：分别保存到单独的配置文件
> - In package.json：保存到 package.json 文件中
>
> 这里建议选择第 1 个，保存到单独的配置文件，这样方便我们做自定义配置。


```shell
? Save this as a preset for future projects? (y/N) N
```
> 这里里是问你是否需要将刚才选择的一系列配置保存起来，然后它可以帮你记住上面的一系列选择，以便下次直接重用。

> 这里根据自己需要输入 y 或者 n，我这里输入 n 不需要。


```shell
Vue CLI v4.5.11
✨  Creating project in D:\project\git\material-management\material-vue.
🗃  Initializing git repository...
⚙️  Installing CLI plugins. This might take a while...

[     .............] \ idealTree:webpack-log: sill fetch manifest randombytes@^2.1.0   
```
> 向导配置结束，开始装包。
> 安装包的时间可能较长，请耐心等待......


```shell
D:\project\git\material-management>vue create material-vue


Vue CLI v4.5.11
? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, Router, Vuex, CSS Pre-processors, Linter
? Choose a version of Vue.js that you want to start the project with 3.x (Preview)
? Use history mode for router? (Requires proper server setup for index fallback in production) No
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less
? Pick a linter / formatter config: Standard
? Pick additional lint features: Lint on save, Lint and fix on commit
? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? No


Vue CLI v4.5.11
✨  Creating project in D:\project\git\material-management\material-vue.
🗃  Initializing git repository...
⚙️  Installing CLI plugins. This might take a while...


added 1283 packages in 3m
🚀  Invoking generators...
📦  Installing additional dependencies...


added 238 packages in 17s
⚓  Running completion hooks...

📄  Generating README.md...

🎉  Successfully created project material-vue.
👉  Get started with the following commands:

 $ cd material-vue
 $ npm run serve
```
安装结束，命令提示你项目创建成功，按照命令行的提示在终端中分别输入：

```shell
# 进入你的项目目录
cd material-vue

# 启动开发服务
npm run serve
```




```shell
 DONE  Compiled successfully in 10708ms                                                   


  App running at:
  - Local:   http://localhost:8080/
  - Network: http://192.168.72.74:8080/

  Note that the development build is not optimized.
  To create a production build, run npm run build.
```
> 启动成功，命令行中输出项目的 http 访问地址。
> 打开浏览器，输入其中任何一个地址进行访问。



如果能看到该页面，恭喜你，项目创建成功了。

![image-20210313083524556](D:\project\git\material-management\课件\assets\image-20210313083524556.png)



## （二）加入 Git 版本管理

建议在项目的一开始就加入版本管理，通过版本管理，我们可以得到很多好处，例如：

- 代码备份
- 多人协作
- 历史记录
- ....

下面是具体的操作流程。

（1）创建远程仓库（GitHub、Gitee、coding）。。。。

（2）把本地仓库推送到远程仓库

如果没有本地仓库：

```shell
# 初始化本地仓库
git init

# 把文件添加到暂存区
git add README.md

# 把暂存区文件提交到本地仓库形成历史记录
git commit -m "first commit"

# 添加远端仓库地址到本地仓库
git remote add origin https://github.com/lipengzhou/toutiao-publish-admin.git

# 推送到远程仓库
git push -u origin master
```



如果已有本地仓库

> VueCLI 在创建项目的时候自动帮你初始化了 `Git` 仓库，并且基于初始代码默认执行了一次提交。

```shell
git remote add origin https://github.com/lipengzhou/toutiao-publish-admin.git

# -u 就是记住本次推送的信息，下次就不用写推送信息了，可以直接 git push
git push -u origin master
```

（3）之后如果有代码变动需要提交

```shell
git add
git commit

# 推送到远程仓库
# 推送的时候如果不改变远程仓库和分支的话就直接
git push

# 如果推送的远程仓库或是分支改变了
$ git push -u 远程仓库 分支名称
```



> 扩展：管理远程仓库地址信息
>
> ```shell
> # 查看使用帮助
> git remote --help
> 
> # 查看所有的远程仓库信息
> git remote -v
> 
> # 添加远程仓库地址信息
> git remote add 名称 远程仓库地址
> 
> # 删除指定的远程仓库信息
> git remote remove 名称
> 
> # 修改远程仓库地址信息
> git remote set-url 远程仓库地址名称 新地址
> ```

## （三）调整初始目录结构

这里主要就是下面的两个工作：

- 删除初始化的默认文件
- 新增调整我们需要的目录结构

1、将 `App.vue` 修改为：

```html
<template>
  <div id="app">
    <!-- 路由出口 -->
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>
<style lang="less"></style>

```

2、将 `router/index.js` 修改为：

```javascript
import { createRouter, createWebHashHistory } from 'vue-router'

const routes = []

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router

```

3、删除默认生成的不相关文件：

- src/views/About.vue
- src/views/Home.vue
- src/components/HelloWorld.vue
- src/assets/logo.png



4、增加以下几个目录

- src/api 目录
  - 存储接口模块
- src/utils 目录
  - 存储一些工具模块
- src/assets/styles 目录
  - index.less 文件，设置全局样式
  - 在 `main.js` 中加载全局样式 `import './assets/styles/index.less'`

5、将 `main.js` 修改为：

```
/**
 * 项目的启动入口
 */
import { createApp } from 'vue'
import App from './App.vue'
// 路由设置
import router from './router'
// 注册状态管理
import store from './store'
// 引入全局样式设置
import './assets/styles/index.less'

// 创建 Vue 根实例
// 把 router 配置到根实例中
// 把 vuex 配置到根实例中
const app = createApp(App)
app.use(store)
app.use(router)
app.mount('#app')
// createApp(App).use(store).use(router).mount('#app')
```

调整之后的目录结构如下。

```
.                                 
├── README.md                     
├── babel.config.js               
├── package-lock.json             
├── package.json                  
├── public                        
│   ├── favicon.ico               
│   └── index.html                
└── src                           
    ├── api
    ├── App.vue                   
    ├── assets  
    	├── styles  
    ├── components                
    ├── main.js                   
    ├── router
    ├── store 
    ├── utils                 
    └── views
```

## （四）JavaScript 代码规范

#### 什么是编码规范

#### 如何统一编码规范

ESLint。

#### 流行的编码规范

- Airbnb JavaScript Style
  - 非常严谨，规则特别多

- JavaScript Standard Style
  - 相比 Airbnb JavaScript Style 要宽松一些。

我们项目中使用的是 [JavaScript Standard Style](https://standardjs.com/readme-zhcn.html) 代码风格。下面是它的一些具体规则要求：

#### JavaScript Standard Style 规范说明

建议把：https://standardjs.com/rules-zhcn.html 看一遍，然后在写的时候遇到错误就查询解决。

- **使用两个空格** – 进行缩进

- **字符串使用单引号** – 需要转义的地方除外

- **不再有冗余的变量** – 这是导致 _大量_ bug 的源头!

- **无分号** – [这](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding)[没什么不好。](http://inimino.org/~inimino/blog/javascript_semicolons)[不骗你！](https://www.youtube.com/watch?v=gsfbh17Ax9I)

- 行首不要以 `(`, `[`, or ``` 开头

  - 这是省略分号时**唯一**会造成问题的地方 – _工具里已加了自动检测！_
  - [详情](https://standardjs.com/rules-zhcn.html#semicolons)

- **关键字后加空格** `if (condition) { ... }`

- **函数名后加空格** `function name (arg) { ... }`

- 坚持使用全等 `===` 摒弃 `==` 一但在需要检查 `null || undefined` 时可以使用 `obj == null`。

- 一定要处理 Node.js 中错误回调传递进来的 `err` 参数。

- 使用浏览器全局变量时加上 `window` 前缀

  - document 和 navigator 除外

  - 避免无意中使用到了这些命名看上去很普通的全局变量， `open`, `length`, `event` 还有 `name`。

- **查看更多** – _为何不试试 standard 规范呢！_

说了那么多，看看[这个遵循了 Standard 规范的示例文件](https://github.com/expressjs/body-parser/blob/master/index.js) 中的代码吧。或者，这里还有[一大波使用了此规范的项目](https://raw.githubusercontent.com/standard/standard-packages/master/all.json) 代码可供参考。

#### 如何解决代码规范错误

<img src="assets/image-20200420112418029.png" alt="image-20200420112418029" style="zoom:50%;" />

如果你不认识命令行中的语法报错是什么意思，你可以根据错误代号去 ESLint 规则列表中查找其具体含义。

什么是错误代号？

<img src="./assets/1561024746437.png" alt="1561024746437" style="zoom:50%;" />

> 括号中的就是错误代码。
>
> semi
>
> keyword-spacing
>
> space-before-function-paren

打开 [ESLint 规则表](https://cn.eslint.org/docs/rules/)，使用页面搜索（Ctrl + F）这个代码，查找对该规则的一个释义。

<img src="./assets/1561024887156.png" alt="1561024887156" style="zoom:50%;" />

> 例如我通过页面页面查找 `space-before-function-paren` 规则代号的释义。

#### 关于 Vue.js 代码规范

> 非强制要求，但是建议按照一定格式来写。

参考：[官方风格指南](https://cn.vuejs.org/v2/style-guide/)。

## （五）Element-plus 组件库

#### Element-plus 介绍

Element-plus 是饿了么前端团队开发的一个基于 Vue.js 的桌面端组件库，它提供的组件非常丰富，不仅功能强大，而且简单易用。

Element-plus 非常的流行，大多数基于 Vue.js 开发的管理系统都会使用到它。

- 官网：https://element-plus.gitee.io/
- GitHub 仓库：https://github.com/ElemeFE/element
  - 目前已有 44.8k 的 Star 了

#### 导入到项目中

1、安装

```bash
npm install element-plus --save
```

2、在 `main.js` 中配置 element -plus组件库

```js
/**
 * 项目的启动入口
 */
import { createApp } from 'vue'
import App from './App.vue'
// 路由设置
import router from './router'
// 注册状态管理
import store from './store'
// 引入全局样式设置
import './assets/styles/index.less'

// 整个 Element Plus 组件库
import ElementPlus from 'element-plus'
// 加载 element 组件库的样式
import 'element-plus/lib/theme-chalk/index.css'

// 创建 Vue 根实例
// 把 router 配置到根实例中
// 把 vuex 配置到根实例中
// 把 ElementPlus 配置到根实例中
const app = createApp(App)
app.use(store)
app.use(router)
app.use(ElementPlus)
app.mount('#app')
// createApp(App).use(store).use(router).mount('#app')
```

#### 使用说明

用哪个组件就看哪个组件的说明文档。

复制 -> 粘贴 -> try-try-see。



## （六）Axios封装请求

1、简介

Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。简单来说就是前端最火最简单的一个http请求解决方案。

2、安装

```
npm install axios
```

3、功能

- 从浏览器中创建 XMLHttpRequests
- 从 node.js 创建 http 请求
- 支持 Promise API
- 拦截请求和响应
- 转换请求数据和响应数据
- 取消请求
- 自动转换 JSON 数据
- 客户端支持防御 XSRF

4、代码封装

（1）工具类封装

为了方便，我们在这里把 axios 单独封装一个模块用于项目中的请求操作。

```js
/**
 * 基于 axios 封装的请求模块
 */
// 引入axios
import axios from 'axios';

// 创建axios实例
const httpService = axios.create({
    // url前缀-'https://some-domain.com/api/'
    baseURL: process.env.BASE_API, // 需自定义
    // 请求超时时间
    timeout: 3000 // 需自定义
});

// request拦截器
httpService.interceptors.request.use(
    config => {
        // 根据条件加入token-安全携带
        if (true) { // 需自定义
            // 让每个请求携带token
            config.headers['User-Token'] = '';
        }
        return config;
    }, 
    error => {
        // 请求错误处理
        Promise.reject(error);
    }
)

// respone拦截器
httpService.interceptors.response.use(
    response => {
        // 统一处理状态
        const res = response.data;
        if (res.statuscode != 1) { // 需自定义
            // 返回异常
            return Promise.reject({
                status: res.statuscode,
                message: res.message
            });
        } else {
            return response.data;
        }
    },
    // 处理处理
    error => {
         if (error && error.response) {
            switch (error.response.status) {
                case 400:
                    error.message = '错误请求';
                    break;
                case 401:
                    error.message = '未授权，请重新登录';
                    break;
                case 403:
                    error.message = '拒绝访问';
                    break;
                case 404:
                    error.message = '请求错误,未找到该资源';
                    break;
                case 405:
                    error.message = '请求方法未允许';
                    break;
                case 408:
                    error.message = '请求超时';
                    break;
                case 500:
                    error.message = '服务器端出错';
                    break;
                case 501:
                    error.message = '网络未实现';
                    break;
                case 502:
                    error.message = '网络错误';
                    break;
                case 503:
                    error.message = '服务不可用';
                    break;
                case 504:
                    error.message = '网络超时';
                    break;
                case 505:
                    error.message = 'http版本不支持该请求';
                    break;
                default:
                    error.message = `未知错误${error.response.status}`;
            }
        } else {
            error.message = "连接到服务器失败";
        }
        return Promise.reject(error);
    }
)

/*网络请求部分*/

/*
 *  get请求
 *  url:请求地址
 *  params:参数
 * */
export function get(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'get',
            params: params
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

/*
 *  post请求
 *  url:请求地址
 *  params:参数
 * */
export function post(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

/*
 *  文件上传
 *  url:请求地址
 *  params:参数
 * */
export function fileUpload(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params,
            headers: { 'Content-Type': 'multipart/form-data' }
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

export default {
    get,
    post,
    fileUpload
}
```

（2）使用

```
// 引入工具类-目录自定义
import fetch from '@/util/fetch'

// 使用
const TMPURL = ''; // url地址
const params = {}; // 参数
fetch.post(TMPURL + '/login/login', params);
```

## （七）阿里iconfont标签

## （八）项目引入的插件

#### 1、滑动验证模块

安装

```
npm i vue-drag-verify2
```

使用教程

```
https://github.com/yimijianfang/vue-drag-verify.git
```

#### 2、js-cookie

说明

> js-cookie是一个简单的，轻量级的[处理cookies的js API](https://www.npmjs.com/package/js-cookie)。

安装

```
npm install js-cookie
```

引用

```
import Cookies from 'js-cookie'
```

简单使用

```
// 1、创建
//创建简单的cookie
Cookies.set('name', 'value');
//创建有效期为7天的cookie
Cookies.set('name', 'value', { expires: 7 });
//为当前页创建有效期7天的cookie
Cookies.set('name', 'value', { expires: 7, path: '' });
/*
expires
定义有效期。如果传入Number，那么单位为天，你也可以传入一个Date对象，表示有效期至Date指定时间。默认情况下cookie有效期截止至用户退出浏览器。
path
string，表示此cookie对哪个地址可见。默认为”/”。
domain
string，表示此cookie对哪个域名可见。设置后cookie会对所有子域名可见。默认为对创建此cookie的域名和子域名可见。
secure
true或false，表示cookie传输是否仅支持https。默认为不要求协议必须为https。

*/

// 2、取值
Cookies.get('name'); // => 'value'
Cookies.get('nothing'); // => undefined
//获取所有cookie
Cookies.get(); // => { name: 'value' }

// 3、删除值
Cookies.remove('name');
//如果值设置了路径，那么不能用简单的delete方法删除值，需要在delete时指定路径
Cookies.set('name', 'value', { path: '' });
Cookies.remove('name'); // 删除失败
Cookies.remove('name', { path: '' }); // 删除成功
//注意，删除不存在的cookie不会报错也不会有返回

// 4、json相关
Cookies.set('name', { foo: 'bar' });
Cookies.get('nam
Cookies.getJSON('name'); // => { foo: 'bar' }e'); // => '{"foo":"bar"}'
Cookies.get(); // => { name: '{"foo":"bar"}' }

// 用getJSON方法获取cookie，那么js-cookie会用JSON.parse解析string并返回
Cookies.getJSON('name'); // => { foo: 'bar' }
Cookies.getJSON(); // => { name: { foo: 'bar' } }
```

3、nprogress

说明

> 这是一个类似youtube、Medium等网站上的小进度条插件。纳米级的进度条，涓涓细流动画告诉你的用户，一些事情正在发生！

安装

```
npm install --save nprogress
```

使用

> 直接调用 `start()`或者`done()`来控制进度条。

```
NProgress.start();
NProgress.done();

// 可以通过调用 .set(n)来设置进度，n是0-1的数字。
NProgress.set(0.0);     // Sorta same as .start()
NProgress.set(0.4);
NProgress.set(1.0);     // Sorta same as .done()
```



## （九）vuex

#### 1、vuex是什么？

​		vuex是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。chrome安装调试工具 devtools extension

#### 2、单向数据流

![img](D:\project\git\material-management\课件\assets\1531106987.png)

**示意图说明：**

- State：驱动应用的数据源（单向数据流）
- View：以声明方式将 state 映射到视图（静态显示出来的数据源）
- Actions：处理用户在view上面操作而导致的状态变化（数据源变化追踪）

一个简单的demo案例：

```
<template>
    <div>
        <!-- view -->
        <div>{{ count }}</div>
        <button @click="increment">increment</button>
    </div>
</template>
<script>
export default {
    // state
    data () {
        return {
            count: 0
        }
    },
    // actions
    methods: {
        increment () {
            this.count++
        }
    }
}
</script>
<style>

</style>
```

#### 3、vuex解决的问题

- 多个视图组件，包括父子组件，兄弟组件之间的状态共享
- 不同视图组件的行为需要变更同一个状态

#### 4、vuex使用场景

中大型单页应用，需要考虑如何更好地在组件外部管理状态，简单应用不建议使用

#### 5、vuex与全局变量的区别

- 响应式：vuex的状态存储是响应式的，当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新
- 不能直接改变store：不能直接改变store的变化，改变store中状态的唯一途径是commit mutation，方便于跟踪每一个状态的变化

#### 6、vuex核心流程

![img](D:\project\git\material-management\课件\assets\1531106988.png)
**示意图说明：**

1. Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应
2. Dispatch：操作行为触发方法，是唯一能执行action的方法
3. Actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发
4. Commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法
5. Mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等
6. State：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新
7. Getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象

**总结说明：**
Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新

#### 7、安装

```javascript
npm install vuex --save
```

#### 8、简单示例

（1）src/vuex/store.js中写入以下代码：

```javascript
import { createStore } from 'vuex'

/* export default createStore({
  state: {},
  mutations: {},
  actions: {},
  modules: {}
}) */

// 1、state：创建初始化状态
const state = {
  // 放置初始状态
  count: 1
}

// 2、mutations：创建改变状态的方法
const mutations = {
  // 状态变更函数-一般大写
  ADD (state, n) {
    state.count += n
  }
}

// 3、getters：提供外部获取state
const getters = {
  count: function (state) {
    return state.count
  }
}

// 4、actions：创建驱动方法改变mutations
const actions = {
  // 触发mutations中相应的方法-一般小写
  add ({ commit }, data) {
    commit('ADD', data)
  }
}
// 5、全部注入Store中
const store = createStore({
  state,
  mutations,
  getters,
  actions
})

// 6、输出store
export default store
```

**代码说明：**

> - state - mutations - getters - actions - store，以上写法基本固定。
> - 小型项目用上面的简单管理状态即可。

（2）src/main.js代码中

```javascript
/**
 * 项目的启动入口
 */
import { createApp } from 'vue'
import App from './App.vue'
// 注册状态管理
import store from './store'

// 创建 Vue 根实例
// 把 vuex 配置到根实例中
const app = createApp(App)
app.use(store) // 全局引入 vuex
app.mount('#app')
// createApp(App).use(store).use(router).mount('#app')

```

（3）src/compontent/Count.vue页面组件中代码如下：

```javascript
<template>
    <div class="hello">
        <h1>{{ msg }}</h1>
        <h2>{{count}}</h2>
        <button @click="clickAdd">新增</button>
    </div>
</template>
<script>
export default {
    data () {
        return {
            msg: 'Vuex test!'
        }
    },
    computed: {
        // 获取state值
        count() {
            return this.$store.state.count;
        }
    },
    methods: {
        clickAdd() {
            //分发action中的add方法
            this.$store.dispatch('add', 1);
        }
    }
}
</script>
<style scoped>
</style>
```

#### 9、state-状态对象的获取方法

**（1）在组件的template中直接使用**

```javascript
<h2>{{ $store.state.count }}</h2>
```

**（2）在计算属性computed中直接赋值**

```javascript
// 方式1：直接获取
computed: {
    count() {
        // this指的是main.js中的vue实例对象
        return this.$store.state.count;
    }
}
```

**（3）通过mapState的对象来赋值**

```javascript
// 方式2：利用mapState
computed: mapState({
    // es5写法
    count: function (state) {
         return state.count;
     },
    // es6写法
    count: state => state.count
})
```

**（4）通过mapState的数组来赋值**

```javascript
// 方式3：数组获取
computed: mapState(['count'])
```

**（5）通过mapState的JSON来赋值**

```javascript
// 方式4：JSON获取
computed: mapState({
    count: 'count'
})
```

PS：一般4和5两种比较常用
**完整示例代码**

```javascript
<template>
    <div class="hello">
        <h1>{{ msg }}</h1>
        <h2>{{ $store.state.count }}</h2>
        <h2>{{count}}</h2>
        <button @click="clickAdd">新增</button>
    </div>
</template>
<script>
import {mapState} from 'vuex'
export default {
    data () {
        return {
            msg: 'Vuex test!'
        }
    },
    // 方式1：在计算属性computed中直接赋值
    // computed: {
    //     count() {
    //         // this指的是main.js中的vue实例对象
    //         return this.$store.state.count;
    //     }
    // },
    // 方式2：通过mapState的对象来赋值
    // computed: mapState({
    //     // es5
    //     // count: function (state) {
    //     //     return state.count;
    //     // },
    //     // es6
    //     count: state => state.count
    // }),
    // 方式3：通过mapState的对象来赋值
    // computed: mapState(['count']),
    // 方式4：通过mapState的JSON来赋值
    computed: mapState({
        count: 'count'
    }),
    methods: {
        clickAdd() {
            //分发action中的add方法
            this.$store.dispatch('add', 1);
        }
    }
}
</script>
<style scoped>
</style>
```

#### 10、mutations-getters-actions异步

**（1）mutations（修改状态）**

template中直接使用$store.commit( )触发

```javascript
// template
<button @click="$store.commit('ADD')">+</button>

// src/vuex/store.js
const mutations = {
    // 状态变更函数
    ADD (state) {
        state.count++;
    }
}
```

利用mapMutations引入触发

```javascript
<template>
    <div class="hello">
        <h1>{{ msg }}</h1>
        <h2>{{count}}</h2>
        <!-- 3、、直接调用相应的方法 -->
        <button @click="ADD">+</button>
    </div>
</template>
<script>
// 1、引入mapMutations
import {mapState, mapMutations} from 'vuex'
export default {
    data () {
        return {
            msg: 'Vuex test!'
        }
    },
    // 通过mapState的JSON来赋值
    computed: mapState({
        count: 'count'
    }),
    // 2、methods中加入mapMutations
    methods: mapMutations([
        'ADD'
    ])
}
</script>
<style scoped>

</style>
```

**（2）getters（获取state和过滤）**

基本用法

```javascript
// src/vuex/store.js
const getters = {
    count: function(state){
        // 返回加上100
        return state.count + 100;
    }
}
```

常规获取值

```javascript
computed: {
    // 获取getters
    count(){
        return this.$store.getters.count;
    }
}
```

mapGetters获取值

```javascript
// 1、引入mapMutations
import {mapState, mapMutations, mapGetters} from 'vuex'

// 2、使用
computed: {
    // 获取getters
    ...mapGetters(["count"])
}
```

**（3）actions（异步状态修改）**

actions和mutations功能基本一样，不同点是，actions是异步的改变state状态，而mutations是同步改变状态。不过实际项目中一般都是通过actions改变mutations中的值。
store.js中增加异步代码

```javascript
// src/vuex/store.js
const actions ={
    // 触发mutations中相应的方法
    add ({commit}) {
        // 增加异步
        setTimeout(()=>{
            commit('ADD')
        },3000);
        console.log('我比reduce提前执行');
    }
}
```

常规使用

```javascript
// template
<button @click="add">+</button>

// script
methods: {
    add() {
        //分发action
        this.$store.dispatch('add');
    }
}
```

mapActions的使用

```javascript
// template
<button @click="add">+</button>

// script
// 引入mapActions
import {mapState, mapActions} from 'vuex'
// 使用mapActions
methods: {
    ...mapActions(['add'])
}
```

#### 11、传递参数

在vuex的方法调用用传递参数，只需要在mutations和actions相应的地方加上参数，然后调用的时候传入即可。
src/vuex/store.js中

```javascript
// actions中传递参数
const mutations = {
    ADD (state, n) {
        state.count += n;
    }
}

// actions中传递参数
const actions ={
    // 触发mutations中相应的方法
    add ({commit}, n) {
        // 增加异步
        setTimeout(()=>{
            commit('ADD', n);
        },3000);
        console.log('我比reduce提前执行');
    }
}
```

页面组件常规调用传递

```javascript
// template
<button @click="add">+</button>

// script
methods: {
    add() {
        // 分发action
        this.$store.dispatch('add', 99);
     }
}
```

页面组件使用mapActions调用传递

```javascript
// template
<button @click="add(99)">+</button>

// script
methods: {
    ...mapActions(['add'])
}
```

#### 12、module-模块组

当应用非常复杂，状态非常多的时候，需要将store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块，从上至下进行同样方式的分割。

**（1）大致的结构**

```javascript
// 模块A
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

// 模块B
const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

// 组装
const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

// 取值
store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

**（2）详细示例**

实际开发中建议把module分开编写。
src/vuex/module1.js

```javascript
// 模块1
const module1 = {
    // 初始化状态
    state: {
        module1: {
            name: '模块1'
        }
    },
    // 编写动作
    mutations: {
        CHANGE1 (state, data) {
            state.module1 = data;
        }
    },
    // 取值
    getters: {
        module1: function(state){
            return state.module1;
        }
    },
    // 创建驱动，可异步
    actions: {
        change1 ({commit}, data) {
            commit('CHANGE1', data)
        }
    }
}

export default module1;
```

src/vuex/module2.js

```javascript
// 模块1
const module2 = {
    // 初始化状态
    state: {
        module2: {
            name: '模块2'
        }
    },
    // 编写动作
    mutations: {
        CHANGE2 (state, data) {
            state.module2 = data;
        }
    },
    // 取值
    getters: {
        module2: function(state){
            return state.module2;
        }
    },
    // 创建驱动，可异步
    actions: {
        change2 ({commit}, data) {
            commit('CHANGE2', data)
        }
    }
}

export default module2;
```

src/vuex/store.js

```javascript
// 引入vue
import Vue from 'vue'
// 引入vuex
import Vuex from 'vuex'
// 引入module1
import module1 from '@/vuex/module1'
// 引入module2
import module2 from '@/vuex/module2'

// 使用vuex
Vue.use(Vuex)

// 模块注入
const store = new Vuex.Store({
    modules: {
        a: module1,
        b: module2
    }
})

// 输出store
export default store;
```

组件中使用，src/compontent/one.vue

```javascript
<template>
    <div id="app">
        <!-- module1 -->
        <h2>{{ module1.name }}</h2>
        <button @click="change1({'name': 'change1'})">module1改变</button>

        <!-- module2 -->
        <h2>{{ module2.name }}</h2>
        <button @click="change2({'name': 'change2'})">module2改变</button>
    </div>
</template>

<script>
// 引入快捷方法
import {mapState, mapGetters, mapActions} from 'vuex'

export default {
    name: 'app',
    data () {
        return {
        }
    },
    computed:{
        // mapState取值
        // ...mapState({
        //     module1: state => state.a.module1.name,
        //     module2: state => state.b.module2.name
        // })

        // mapGetter取值
        ...mapGetters(['module1', 'module2'])
    },
    methods: {
        // mapAction取方法
        ...mapActions([
            'change1',
            'change2'
        ])
    }
}
</script>
<style>

</style>
```

PS：module中命名要唯一，不然获取值和改变值的时候会冲突，目前亲测mapGetters只能获取对象。

# 异常处理

#### 1.vue3报错Uncaught Error: Catch all routes ("*") must now be defined using a param with a custom regexp.

**vue3对404配置进行了修改,必须要使用正则匹配**

```
{
    // 匹配所有路径  vue2使用*   vue3使用/:pathMatch(.*)*或/:pathMatch(.*)或/:catchAll(.*)
    path: "/:pathMatch(.*)*",
    name: "404",
    component: ()=> import("../components/NoFind.vue")
}
```

> 原因：Vue Router不再使用path-to-regexp，而是实现了自己的解析系统，该系统允许路由排名并启用动态路由。由于我们通常会在每个项目中添加一条单独的包罗万象的路线，因此支持的特殊语法没有太大的好处*。参数的编码是跨路线编码，无一例外使事情更容易预测。